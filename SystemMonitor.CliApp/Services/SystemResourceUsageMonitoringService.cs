using System.Threading.Channels;
using Microsoft.Extensions.Logging;
using SystemMonitor.Core.Interfaces;
using SystemMonitor.Core.Models;
using SystemMonitor.Infrastructure.Plugins;

namespace SystemMonitor.CliApp.Services;

/// <summary>
/// Service responsible for monitoring system resource usage and dispatching the data
/// to loaded <see cref="ISystemMonitorPlugin"/> instances.
/// </summary>
public class SystemResourceUsageMonitoringService
{
    // list of plugins which are loaded and enabled
    private List<ISystemMonitorPlugin> _listOfLoadedAndEnabledPlugins = [];
    private readonly ILogger<SystemResourceUsageMonitoringService> _logger;
    private readonly ISystemResourceUsageDataProvider  _dataProvider;
    private readonly DirectoryPluginLoader _pluginLoader;
    
    public SystemResourceUsageMonitoringService(ILogger<SystemResourceUsageMonitoringService> logger, SystemResourceUsageDataProviderResolver resolver, DirectoryPluginLoader pluginLoader)
    {
        _logger = logger;
        _pluginLoader = pluginLoader;
        var dataProvider = resolver.GetSystemResourceUsageDataProvider();
        if (dataProvider is null)
        {
            logger.LogError("No SystemResourceUsageDataProvider found");
            throw new Exception("No SystemResourceUsageDataProvider found");
        }
        _dataProvider = dataProvider;
    }

    /// <summary>
    /// Utility to load plugins, can be called multiple times to load more plugins
    /// </summary>
    /// <param name="pluginDir"></param>
    /// <param name="enabledPlugins"></param>
    public void LoadPluginsFromDirectory(string pluginDir, List<string> enabledPlugins)
    {
        _pluginLoader.LoadPluginsFromDirectory(pluginDir);
        _listOfLoadedAndEnabledPlugins = _pluginLoader.LoadedSystemMonitorPlugins.Where(p => enabledPlugins.Contains(p.Name)).ToList();
    }

    /// <summary>
    /// Runs the monitoring service by starting the producer and consumer tasks,
    /// and waits for them to complete.
    /// </summary>
    /// <param name="delay"></param>
    public async Task Run(int delay)
    {
        // If there are no plugins to run then exit early
        if (_listOfLoadedAndEnabledPlugins.Count == 0)
        {
            _logger.LogWarning("No Loaded and Enabled Plugins found");
            return;
        }
        
        // print enabled plugins
        _logger.LogInformation($"Following plugins will be executed: [{string.Join(", ", _listOfLoadedAndEnabledPlugins.Select(p => p.Name))}]");
        
        var cts = new CancellationTokenSource();
        // Prevent immediate process kill and wait for all producers and consumers to finish
        Console.CancelKeyPress += (s, e) =>
        {
            _logger.LogInformation("Shut Down Requested");
            e.Cancel = true;
            _logger.LogInformation("Waiting for plugins to finish execution...");
            cts.Cancel();
        };

        var pluginChannelMap = new Dictionary<ISystemMonitorPlugin, Channel<SystemResourceUsageDto>>();
        // create channels for each plugin
        foreach (var plugin in _listOfLoadedAndEnabledPlugins)
        {
            var channel = Channel.CreateUnbounded<SystemResourceUsageDto>();
            pluginChannelMap[plugin] = channel;
        }
        
        // Producer produces the system resource usage data
        var producer = Task.Run(async () =>
        {
            try
            {
                while (!cts.Token.IsCancellationRequested)
                {
                    var usage = _dataProvider.GetSystemResourceUsage();
                    // send system resource usage data to each plugin
                    foreach (var plugin in _listOfLoadedAndEnabledPlugins)
                    {
                        await pluginChannelMap[plugin].Writer.WriteAsync(usage, cts.Token);
                    }
                    // delay before talking next reading of system usage
                    await Task.Delay(delay, cts.Token);
                }
            }
            catch (OperationCanceledException e)
            {
                // Nothing to do here
            }
            finally
            {
                foreach (var channel in pluginChannelMap.Values)
                {
                    channel.Writer.Complete();
                }
            }
        }, cts.Token);
        // list of consumer plugin tasks
        List<Task> consumers = [];
        foreach (var plugin in _listOfLoadedAndEnabledPlugins)
        {
            var consumer = Task.Run(async () =>
            {
                try
                {
                    // Consume the data generated by producer
                    await foreach (var usage in pluginChannelMap[plugin].Reader.ReadAllAsync(cts.Token))
                    {
                        try
                        {
                            await plugin.OnSystemResourceUsageDataReceived(usage);
                        }
                        catch (Exception e)
                        {
                            _logger.LogError(e, "Plugin {plugin} failed", plugin.GetType().Name);
                        }
                    }
                }
                catch (OperationCanceledException e)
                {
                    // Nothing to do here
                }
            }, cts.Token);
            consumers.Add(consumer);
        }

        var allTasks = new List<Task> { producer };
        allTasks.AddRange(consumers);
        // wait for producer and consumer to finish
        await Task.WhenAll(allTasks);
    }
}